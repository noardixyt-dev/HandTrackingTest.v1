<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hand Tracking Test</title>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  #status { position:absolute; top:10px; left:10px; color:white; background:rgba(0,0,0,0.5); padding:5px 10px; border-radius:5px; z-index:10; }
</style>
</head>
<body>
<div id="status">Pinch: No</div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

let scene, camera, renderer;
let handMesh = null;
let pinchStatus = document.getElementById('status');
let video = null;

// Initialize Three.js
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
camera.position.set(0,0,2);

renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.HemisphereLight(0xffffff,0x444444,1);
scene.add(light);

// 3D hand sphere
const geometry = new THREE.SphereGeometry(0.05,16,16);
const material = new THREE.MeshStandardMaterial({color:0x00ff00});
handMesh = new THREE.Mesh(geometry, material);
scene.add(handMesh);

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Hand tracking setup
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.5
});
hands.onResults(onResults);

// Force camera permission prompt immediately
async function initCamera() {
  try {
    video = document.createElement('video');
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true;

    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
    video.srcObject = stream;
    await video.play();

    // Video texture for Three.js background
    const videoTexture = new THREE.VideoTexture(video);
    videoTexture.minFilter = THREE.LinearFilter;
    videoTexture.magFilter = THREE.LinearFilter;
    videoTexture.format = THREE.RGBFormat;
    scene.background = videoTexture;

    const mpCamera = new Camera(video, {
      onFrame: async () => { await hands.send({image: video}); },
      width: 640,
      height: 480
    });
    mpCamera.start();

  } catch(e) {
    console.error("Camera access error:", e);
    alert("Camera permission denied or unavailable. Please allow camera to use this app.");
  }
}

// Hand tracking results
let isPinched = false;
function onResults(results){
  if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
    const lm = results.multiHandLandmarks[0];
    // pinch detection: thumb tip to index tip
    const dx = lm[4].x - lm[8].x;
    const dy = lm[4].y - lm[8].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    isPinched = dist < 0.05;
    pinchStatus.textContent = "Pinch: " + (isPinched ? "Yes" : "No");

    // move 3D sphere with wrist
    const wrist = lm[0];
    handMesh.position.set((wrist.x-0.5)*2, (0.5-wrist.y)*2, -wrist.z*2);
  } else {
    pinchStatus.textContent = "Pinch: No";
  }
}

// Render loop
function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}

// Start
initCamera();
animate();

</script>
</body>
</html>
